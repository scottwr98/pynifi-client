# coding: utf-8

"""
    NiFi Rest Api

    The Rest Api provides programmatic access to command and control a NiFi instance in real time. Start and                                              stop processors, monitor queues, query provenance data, and more. Each endpoint below includes a description,                                             definitions of the expected input and output, potential response codes, and the authorizations required                                             to invoke each service.  # noqa: E501

    OpenAPI spec version: 1.4.0
    Contact: dev@nifi.apache.org
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class FlowApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def activate_controller_services(self, id, body, **kwargs):  # noqa: E501
        """Enable or disable Controller Services in the specified Process Group.  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.activate_controller_services(id, body, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: The process group id. (required)
        :param ActivateControllerServicesEntity body: The request to schedule or unschedule. If the comopnents in the request are not specified, all authorized components will be considered. (required)
        :return: ActivateControllerServicesEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.activate_controller_services_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.activate_controller_services_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def activate_controller_services_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """Enable or disable Controller Services in the specified Process Group.  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.activate_controller_services_with_http_info(id, body, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: The process group id. (required)
        :param ActivateControllerServicesEntity body: The request to schedule or unschedule. If the comopnents in the request are not specified, all authorized components will be considered. (required)
        :return: ActivateControllerServicesEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method activate_controller_services" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `activate_controller_services`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `activate_controller_services`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/flow/process-groups/{id}/controller-services', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ActivateControllerServicesEntity',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def generate_client_id(self, **kwargs):  # noqa: E501
        """Generates a client id.  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.generate_client_id(async=True)
        >>> result = thread.get()

        :param async bool
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.generate_client_id_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.generate_client_id_with_http_info(**kwargs)  # noqa: E501
            return data

    def generate_client_id_with_http_info(self, **kwargs):  # noqa: E501
        """Generates a client id.  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.generate_client_id_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method generate_client_id" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/flow/client-id', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_about_info(self, **kwargs):  # noqa: E501
        """Retrieves details about this NiFi to put in the About dialog  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_about_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: AboutEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_about_info_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_about_info_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_about_info_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieves details about this NiFi to put in the About dialog  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_about_info_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: AboutEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_about_info" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/flow/about', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AboutEntity',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_action(self, id, **kwargs):  # noqa: E501
        """Gets an action  # noqa: E501

        Note: This endpoint is subject to change as NiFi and it's REST API evolve.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_action(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: The action id. (required)
        :return: ActionEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_action_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_action_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_action_with_http_info(self, id, **kwargs):  # noqa: E501
        """Gets an action  # noqa: E501

        Note: This endpoint is subject to change as NiFi and it's REST API evolve.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_action_with_http_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: The action id. (required)
        :return: ActionEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_action" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_action`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/flow/history/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ActionEntity',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_banners(self, **kwargs):  # noqa: E501
        """Retrieves the banners for this NiFi  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_banners(async=True)
        >>> result = thread.get()

        :param async bool
        :return: BannerEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_banners_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_banners_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_banners_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieves the banners for this NiFi  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_banners_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: BannerEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_banners" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/flow/banners', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BannerEntity',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_bulletin_board(self, **kwargs):  # noqa: E501
        """Gets current bulletins  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_bulletin_board(async=True)
        >>> result = thread.get()

        :param async bool
        :param str after: Includes bulletins with an id after this value.
        :param str source_name: Includes bulletins originating from this sources whose name match this regular expression.
        :param str message: Includes bulletins whose message that match this regular expression.
        :param str source_id: Includes bulletins originating from this sources whose id match this regular expression.
        :param str group_id: Includes bulletins originating from this sources whose group id match this regular expression.
        :param str limit: The number of bulletins to limit the response to.
        :return: BulletinBoardEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_bulletin_board_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_bulletin_board_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_bulletin_board_with_http_info(self, **kwargs):  # noqa: E501
        """Gets current bulletins  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_bulletin_board_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str after: Includes bulletins with an id after this value.
        :param str source_name: Includes bulletins originating from this sources whose name match this regular expression.
        :param str message: Includes bulletins whose message that match this regular expression.
        :param str source_id: Includes bulletins originating from this sources whose id match this regular expression.
        :param str group_id: Includes bulletins originating from this sources whose group id match this regular expression.
        :param str limit: The number of bulletins to limit the response to.
        :return: BulletinBoardEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['after', 'source_name', 'message', 'source_id', 'group_id', 'limit']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bulletin_board" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'after' in params:
            query_params.append(('after', params['after']))  # noqa: E501
        if 'source_name' in params:
            query_params.append(('sourceName', params['source_name']))  # noqa: E501
        if 'message' in params:
            query_params.append(('message', params['message']))  # noqa: E501
        if 'source_id' in params:
            query_params.append(('sourceId', params['source_id']))  # noqa: E501
        if 'group_id' in params:
            query_params.append(('groupId', params['group_id']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/flow/bulletin-board', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BulletinBoardEntity',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_bulletins(self, **kwargs):  # noqa: E501
        """Retrieves Controller level bulletins  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_bulletins(async=True)
        >>> result = thread.get()

        :param async bool
        :return: ControllerBulletinsEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_bulletins_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_bulletins_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_bulletins_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieves Controller level bulletins  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_bulletins_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: ControllerBulletinsEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bulletins" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/flow/controller/bulletins', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ControllerBulletinsEntity',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_cluster_summary(self, **kwargs):  # noqa: E501
        """The cluster summary for this NiFi  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_cluster_summary(async=True)
        >>> result = thread.get()

        :param async bool
        :return: ClusteSummaryEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_cluster_summary_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_cluster_summary_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_cluster_summary_with_http_info(self, **kwargs):  # noqa: E501
        """The cluster summary for this NiFi  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_cluster_summary_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: ClusteSummaryEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_cluster_summary" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/flow/cluster/summary', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClusteSummaryEntity',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_component_history(self, component_id, **kwargs):  # noqa: E501
        """Gets configuration history for a component  # noqa: E501

        Note: This endpoint is subject to change as NiFi and it's REST API evolve.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_component_history(component_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str component_id: The component id. (required)
        :return: ComponentHistoryEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_component_history_with_http_info(component_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_component_history_with_http_info(component_id, **kwargs)  # noqa: E501
            return data

    def get_component_history_with_http_info(self, component_id, **kwargs):  # noqa: E501
        """Gets configuration history for a component  # noqa: E501

        Note: This endpoint is subject to change as NiFi and it's REST API evolve.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_component_history_with_http_info(component_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str component_id: The component id. (required)
        :return: ComponentHistoryEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['component_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_component_history" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'component_id' is set
        if ('component_id' not in params or
                params['component_id'] is None):
            raise ValueError("Missing the required parameter `component_id` when calling `get_component_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'component_id' in params:
            path_params['componentId'] = params['component_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/flow/history/components/{componentId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ComponentHistoryEntity',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_connection_status(self, id, **kwargs):  # noqa: E501
        """Gets status for a connection  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_connection_status(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: The connection id. (required)
        :param bool nodewise: Whether or not to include the breakdown per node. Optional, defaults to false
        :param str cluster_node_id: The id of the node where to get the status.
        :return: ConnectionStatusEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_connection_status_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_connection_status_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_connection_status_with_http_info(self, id, **kwargs):  # noqa: E501
        """Gets status for a connection  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_connection_status_with_http_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: The connection id. (required)
        :param bool nodewise: Whether or not to include the breakdown per node. Optional, defaults to false
        :param str cluster_node_id: The id of the node where to get the status.
        :return: ConnectionStatusEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'nodewise', 'cluster_node_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_connection_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_connection_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'nodewise' in params:
            query_params.append(('nodewise', params['nodewise']))  # noqa: E501
        if 'cluster_node_id' in params:
            query_params.append(('clusterNodeId', params['cluster_node_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/flow/connections/{id}/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConnectionStatusEntity',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_connection_status_history(self, id, **kwargs):  # noqa: E501
        """Gets the status history for a connection  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_connection_status_history(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: The connection id. (required)
        :return: StatusHistoryEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_connection_status_history_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_connection_status_history_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_connection_status_history_with_http_info(self, id, **kwargs):  # noqa: E501
        """Gets the status history for a connection  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_connection_status_history_with_http_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: The connection id. (required)
        :return: StatusHistoryEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_connection_status_history" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_connection_status_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/flow/connections/{id}/status/history', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StatusHistoryEntity',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_controller_service_types(self, **kwargs):  # noqa: E501
        """Retrieves the types of controller services that this NiFi supports  # noqa: E501

        Note: This endpoint is subject to change as NiFi and it's REST API evolve.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_controller_service_types(async=True)
        >>> result = thread.get()

        :param async bool
        :param str service_type: If specified, will only return controller services that are compatible with this type of service.
        :param str service_bundle_group: If serviceType specified, is the bundle group of the serviceType.
        :param str service_bundle_artifact: If serviceType specified, is the bundle artifact of the serviceType.
        :param str service_bundle_version: If serviceType specified, is the bundle version of the serviceType.
        :param str bundle_group_filter: If specified, will only return types that are a member of this bundle group.
        :param str bundle_artifact_filter: If specified, will only return types that are a member of this bundle artifact.
        :param str type_filter: If specified, will only return types whose fully qualified classname matches.
        :return: ControllerServiceTypesEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_controller_service_types_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_controller_service_types_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_controller_service_types_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieves the types of controller services that this NiFi supports  # noqa: E501

        Note: This endpoint is subject to change as NiFi and it's REST API evolve.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_controller_service_types_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str service_type: If specified, will only return controller services that are compatible with this type of service.
        :param str service_bundle_group: If serviceType specified, is the bundle group of the serviceType.
        :param str service_bundle_artifact: If serviceType specified, is the bundle artifact of the serviceType.
        :param str service_bundle_version: If serviceType specified, is the bundle version of the serviceType.
        :param str bundle_group_filter: If specified, will only return types that are a member of this bundle group.
        :param str bundle_artifact_filter: If specified, will only return types that are a member of this bundle artifact.
        :param str type_filter: If specified, will only return types whose fully qualified classname matches.
        :return: ControllerServiceTypesEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_type', 'service_bundle_group', 'service_bundle_artifact', 'service_bundle_version', 'bundle_group_filter', 'bundle_artifact_filter', 'type_filter']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_controller_service_types" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'service_type' in params:
            query_params.append(('serviceType', params['service_type']))  # noqa: E501
        if 'service_bundle_group' in params:
            query_params.append(('serviceBundleGroup', params['service_bundle_group']))  # noqa: E501
        if 'service_bundle_artifact' in params:
            query_params.append(('serviceBundleArtifact', params['service_bundle_artifact']))  # noqa: E501
        if 'service_bundle_version' in params:
            query_params.append(('serviceBundleVersion', params['service_bundle_version']))  # noqa: E501
        if 'bundle_group_filter' in params:
            query_params.append(('bundleGroupFilter', params['bundle_group_filter']))  # noqa: E501
        if 'bundle_artifact_filter' in params:
            query_params.append(('bundleArtifactFilter', params['bundle_artifact_filter']))  # noqa: E501
        if 'type_filter' in params:
            query_params.append(('typeFilter', params['type_filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/flow/controller-service-types', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ControllerServiceTypesEntity',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_controller_services_from_controller(self, **kwargs):  # noqa: E501
        """Gets all controller services  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_controller_services_from_controller(async=True)
        >>> result = thread.get()

        :param async bool
        :return: ControllerServicesEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_controller_services_from_controller_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_controller_services_from_controller_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_controller_services_from_controller_with_http_info(self, **kwargs):  # noqa: E501
        """Gets all controller services  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_controller_services_from_controller_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: ControllerServicesEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_controller_services_from_controller" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/flow/controller/controller-services', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ControllerServicesEntity',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_controller_services_from_group(self, id, **kwargs):  # noqa: E501
        """Gets all controller services  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_controller_services_from_group(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: The process group id. (required)
        :param bool include_ancestor_groups: Whether or not to include parent/ancestory process groups
        :param bool include_descendant_groups: Whether or not to include descendant process groups
        :return: ControllerServicesEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_controller_services_from_group_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_controller_services_from_group_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_controller_services_from_group_with_http_info(self, id, **kwargs):  # noqa: E501
        """Gets all controller services  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_controller_services_from_group_with_http_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: The process group id. (required)
        :param bool include_ancestor_groups: Whether or not to include parent/ancestory process groups
        :param bool include_descendant_groups: Whether or not to include descendant process groups
        :return: ControllerServicesEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'include_ancestor_groups', 'include_descendant_groups']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_controller_services_from_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_controller_services_from_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'include_ancestor_groups' in params:
            query_params.append(('includeAncestorGroups', params['include_ancestor_groups']))  # noqa: E501
        if 'include_descendant_groups' in params:
            query_params.append(('includeDescendantGroups', params['include_descendant_groups']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/flow/process-groups/{id}/controller-services', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ControllerServicesEntity',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_controller_status(self, **kwargs):  # noqa: E501
        """Gets the current status of this NiFi  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_controller_status(async=True)
        >>> result = thread.get()

        :param async bool
        :return: ControllerStatusEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_controller_status_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_controller_status_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_controller_status_with_http_info(self, **kwargs):  # noqa: E501
        """Gets the current status of this NiFi  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_controller_status_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: ControllerStatusEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_controller_status" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/flow/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ControllerStatusEntity',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_current_user(self, **kwargs):  # noqa: E501
        """Retrieves the user identity of the user making the request  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_current_user(async=True)
        >>> result = thread.get()

        :param async bool
        :return: CurrentUserEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_current_user_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_current_user_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_current_user_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieves the user identity of the user making the request  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_current_user_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: CurrentUserEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_current_user" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/flow/current-user', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CurrentUserEntity',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_flow(self, id, **kwargs):  # noqa: E501
        """Gets a process group  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_flow(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: The process group id. (required)
        :return: ProcessGroupFlowEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_flow_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_flow_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_flow_with_http_info(self, id, **kwargs):  # noqa: E501
        """Gets a process group  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_flow_with_http_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: The process group id. (required)
        :return: ProcessGroupFlowEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_flow" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_flow`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/flow/process-groups/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ProcessGroupFlowEntity',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_flow_config(self, **kwargs):  # noqa: E501
        """Retrieves the configuration for this NiFi flow  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_flow_config(async=True)
        >>> result = thread.get()

        :param async bool
        :return: FlowConfigurationEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_flow_config_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_flow_config_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_flow_config_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieves the configuration for this NiFi flow  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_flow_config_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: FlowConfigurationEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_flow_config" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/flow/config', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FlowConfigurationEntity',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_input_port_status(self, id, **kwargs):  # noqa: E501
        """Gets status for an input port  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_input_port_status(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: The input port id. (required)
        :param bool nodewise: Whether or not to include the breakdown per node. Optional, defaults to false
        :param str cluster_node_id: The id of the node where to get the status.
        :return: PortStatusEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_input_port_status_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_input_port_status_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_input_port_status_with_http_info(self, id, **kwargs):  # noqa: E501
        """Gets status for an input port  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_input_port_status_with_http_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: The input port id. (required)
        :param bool nodewise: Whether or not to include the breakdown per node. Optional, defaults to false
        :param str cluster_node_id: The id of the node where to get the status.
        :return: PortStatusEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'nodewise', 'cluster_node_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_input_port_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_input_port_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'nodewise' in params:
            query_params.append(('nodewise', params['nodewise']))  # noqa: E501
        if 'cluster_node_id' in params:
            query_params.append(('clusterNodeId', params['cluster_node_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/flow/input-ports/{id}/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PortStatusEntity',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_output_port_status(self, id, **kwargs):  # noqa: E501
        """Gets status for an output port  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_output_port_status(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: The output port id. (required)
        :param bool nodewise: Whether or not to include the breakdown per node. Optional, defaults to false
        :param str cluster_node_id: The id of the node where to get the status.
        :return: PortStatusEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_output_port_status_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_output_port_status_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_output_port_status_with_http_info(self, id, **kwargs):  # noqa: E501
        """Gets status for an output port  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_output_port_status_with_http_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: The output port id. (required)
        :param bool nodewise: Whether or not to include the breakdown per node. Optional, defaults to false
        :param str cluster_node_id: The id of the node where to get the status.
        :return: PortStatusEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'nodewise', 'cluster_node_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_output_port_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_output_port_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'nodewise' in params:
            query_params.append(('nodewise', params['nodewise']))  # noqa: E501
        if 'cluster_node_id' in params:
            query_params.append(('clusterNodeId', params['cluster_node_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/flow/output-ports/{id}/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PortStatusEntity',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_prioritizers(self, **kwargs):  # noqa: E501
        """Retrieves the types of prioritizers that this NiFi supports  # noqa: E501

        Note: This endpoint is subject to change as NiFi and it's REST API evolve.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_prioritizers(async=True)
        >>> result = thread.get()

        :param async bool
        :return: PrioritizerTypesEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_prioritizers_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_prioritizers_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_prioritizers_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieves the types of prioritizers that this NiFi supports  # noqa: E501

        Note: This endpoint is subject to change as NiFi and it's REST API evolve.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_prioritizers_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: PrioritizerTypesEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_prioritizers" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/flow/prioritizers', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PrioritizerTypesEntity',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_process_group_status(self, id, **kwargs):  # noqa: E501
        """Gets the status for a process group  # noqa: E501

        The status for a process group includes status for all descendent components. When invoked on the root group with recursive set to true, it will return the current status of every component in the flow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_process_group_status(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: The process group id. (required)
        :param bool recursive: Whether all descendant groups and the status of their content will be included. Optional, defaults to false
        :param bool nodewise: Whether or not to include the breakdown per node. Optional, defaults to false
        :param str cluster_node_id: The id of the node where to get the status.
        :return: ProcessGroupStatusEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_process_group_status_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_process_group_status_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_process_group_status_with_http_info(self, id, **kwargs):  # noqa: E501
        """Gets the status for a process group  # noqa: E501

        The status for a process group includes status for all descendent components. When invoked on the root group with recursive set to true, it will return the current status of every component in the flow.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_process_group_status_with_http_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: The process group id. (required)
        :param bool recursive: Whether all descendant groups and the status of their content will be included. Optional, defaults to false
        :param bool nodewise: Whether or not to include the breakdown per node. Optional, defaults to false
        :param str cluster_node_id: The id of the node where to get the status.
        :return: ProcessGroupStatusEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'recursive', 'nodewise', 'cluster_node_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_process_group_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_process_group_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'recursive' in params:
            query_params.append(('recursive', params['recursive']))  # noqa: E501
        if 'nodewise' in params:
            query_params.append(('nodewise', params['nodewise']))  # noqa: E501
        if 'cluster_node_id' in params:
            query_params.append(('clusterNodeId', params['cluster_node_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/flow/process-groups/{id}/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ProcessGroupStatusEntity',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_process_group_status_history(self, id, **kwargs):  # noqa: E501
        """Gets status history for a remote process group  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_process_group_status_history(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: The process group id. (required)
        :return: StatusHistoryEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_process_group_status_history_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_process_group_status_history_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_process_group_status_history_with_http_info(self, id, **kwargs):  # noqa: E501
        """Gets status history for a remote process group  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_process_group_status_history_with_http_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: The process group id. (required)
        :return: StatusHistoryEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_process_group_status_history" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_process_group_status_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/flow/process-groups/{id}/status/history', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StatusHistoryEntity',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_processor_status(self, id, **kwargs):  # noqa: E501
        """Gets status for a processor  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_processor_status(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: The processor id. (required)
        :param bool nodewise: Whether or not to include the breakdown per node. Optional, defaults to false
        :param str cluster_node_id: The id of the node where to get the status.
        :return: ProcessorStatusEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_processor_status_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_processor_status_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_processor_status_with_http_info(self, id, **kwargs):  # noqa: E501
        """Gets status for a processor  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_processor_status_with_http_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: The processor id. (required)
        :param bool nodewise: Whether or not to include the breakdown per node. Optional, defaults to false
        :param str cluster_node_id: The id of the node where to get the status.
        :return: ProcessorStatusEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'nodewise', 'cluster_node_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_processor_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_processor_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'nodewise' in params:
            query_params.append(('nodewise', params['nodewise']))  # noqa: E501
        if 'cluster_node_id' in params:
            query_params.append(('clusterNodeId', params['cluster_node_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/flow/processors/{id}/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ProcessorStatusEntity',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_processor_status_history(self, id, **kwargs):  # noqa: E501
        """Gets status history for a processor  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_processor_status_history(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: The processor id. (required)
        :return: StatusHistoryEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_processor_status_history_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_processor_status_history_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_processor_status_history_with_http_info(self, id, **kwargs):  # noqa: E501
        """Gets status history for a processor  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_processor_status_history_with_http_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: The processor id. (required)
        :return: StatusHistoryEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_processor_status_history" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_processor_status_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/flow/processors/{id}/status/history', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StatusHistoryEntity',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_processor_types(self, **kwargs):  # noqa: E501
        """Retrieves the types of processors that this NiFi supports  # noqa: E501

        Note: This endpoint is subject to change as NiFi and it's REST API evolve.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_processor_types(async=True)
        >>> result = thread.get()

        :param async bool
        :param str bundle_group_filter: If specified, will only return types that are a member of this bundle group.
        :param str bundle_artifact_filter: If specified, will only return types that are a member of this bundle artifact.
        :param str type: If specified, will only return types whose fully qualified classname matches.
        :return: ProcessorTypesEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_processor_types_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_processor_types_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_processor_types_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieves the types of processors that this NiFi supports  # noqa: E501

        Note: This endpoint is subject to change as NiFi and it's REST API evolve.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_processor_types_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str bundle_group_filter: If specified, will only return types that are a member of this bundle group.
        :param str bundle_artifact_filter: If specified, will only return types that are a member of this bundle artifact.
        :param str type: If specified, will only return types whose fully qualified classname matches.
        :return: ProcessorTypesEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['bundle_group_filter', 'bundle_artifact_filter', 'type']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_processor_types" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'bundle_group_filter' in params:
            query_params.append(('bundleGroupFilter', params['bundle_group_filter']))  # noqa: E501
        if 'bundle_artifact_filter' in params:
            query_params.append(('bundleArtifactFilter', params['bundle_artifact_filter']))  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/flow/processor-types', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ProcessorTypesEntity',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_remote_process_group_status(self, id, **kwargs):  # noqa: E501
        """Gets status for a remote process group  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_remote_process_group_status(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: The remote process group id. (required)
        :param bool nodewise: Whether or not to include the breakdown per node. Optional, defaults to false
        :param str cluster_node_id: The id of the node where to get the status.
        :return: RemoteProcessGroupStatusEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_remote_process_group_status_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_remote_process_group_status_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_remote_process_group_status_with_http_info(self, id, **kwargs):  # noqa: E501
        """Gets status for a remote process group  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_remote_process_group_status_with_http_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: The remote process group id. (required)
        :param bool nodewise: Whether or not to include the breakdown per node. Optional, defaults to false
        :param str cluster_node_id: The id of the node where to get the status.
        :return: RemoteProcessGroupStatusEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'nodewise', 'cluster_node_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_remote_process_group_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_remote_process_group_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'nodewise' in params:
            query_params.append(('nodewise', params['nodewise']))  # noqa: E501
        if 'cluster_node_id' in params:
            query_params.append(('clusterNodeId', params['cluster_node_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/flow/remote-process-groups/{id}/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RemoteProcessGroupStatusEntity',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_remote_process_group_status_history(self, id, **kwargs):  # noqa: E501
        """Gets the status history  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_remote_process_group_status_history(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: The remote process group id. (required)
        :return: StatusHistoryEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_remote_process_group_status_history_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_remote_process_group_status_history_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_remote_process_group_status_history_with_http_info(self, id, **kwargs):  # noqa: E501
        """Gets the status history  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_remote_process_group_status_history_with_http_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: The remote process group id. (required)
        :return: StatusHistoryEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_remote_process_group_status_history" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_remote_process_group_status_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/flow/remote-process-groups/{id}/status/history', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StatusHistoryEntity',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_reporting_task_types(self, **kwargs):  # noqa: E501
        """Retrieves the types of reporting tasks that this NiFi supports  # noqa: E501

        Note: This endpoint is subject to change as NiFi and it's REST API evolve.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_reporting_task_types(async=True)
        >>> result = thread.get()

        :param async bool
        :param str bundle_group_filter: If specified, will only return types that are a member of this bundle group.
        :param str bundle_artifact_filter: If specified, will only return types that are a member of this bundle artifact.
        :param str type: If specified, will only return types whose fully qualified classname matches.
        :return: ReportingTaskTypesEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_reporting_task_types_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_reporting_task_types_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_reporting_task_types_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieves the types of reporting tasks that this NiFi supports  # noqa: E501

        Note: This endpoint is subject to change as NiFi and it's REST API evolve.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_reporting_task_types_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str bundle_group_filter: If specified, will only return types that are a member of this bundle group.
        :param str bundle_artifact_filter: If specified, will only return types that are a member of this bundle artifact.
        :param str type: If specified, will only return types whose fully qualified classname matches.
        :return: ReportingTaskTypesEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['bundle_group_filter', 'bundle_artifact_filter', 'type']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_reporting_task_types" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'bundle_group_filter' in params:
            query_params.append(('bundleGroupFilter', params['bundle_group_filter']))  # noqa: E501
        if 'bundle_artifact_filter' in params:
            query_params.append(('bundleArtifactFilter', params['bundle_artifact_filter']))  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/flow/reporting-task-types', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ReportingTaskTypesEntity',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_reporting_tasks(self, **kwargs):  # noqa: E501
        """Gets all reporting tasks  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_reporting_tasks(async=True)
        >>> result = thread.get()

        :param async bool
        :return: ReportingTasksEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_reporting_tasks_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_reporting_tasks_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_reporting_tasks_with_http_info(self, **kwargs):  # noqa: E501
        """Gets all reporting tasks  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_reporting_tasks_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: ReportingTasksEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_reporting_tasks" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/flow/reporting-tasks', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ReportingTasksEntity',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_templates(self, **kwargs):  # noqa: E501
        """Gets all templates  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_templates(async=True)
        >>> result = thread.get()

        :param async bool
        :return: TemplatesEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_templates_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_templates_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_templates_with_http_info(self, **kwargs):  # noqa: E501
        """Gets all templates  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_templates_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: TemplatesEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_templates" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/flow/templates', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TemplatesEntity',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def query_history(self, offset, count, **kwargs):  # noqa: E501
        """Gets configuration history  # noqa: E501

        Note: This endpoint is subject to change as NiFi and it's REST API evolve.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.query_history(offset, count, async=True)
        >>> result = thread.get()

        :param async bool
        :param str offset: The offset into the result set. (required)
        :param str count: The number of actions to return. (required)
        :param str sort_column: The field to sort on.
        :param str sort_order: The direction to sort.
        :param str start_date: Include actions after this date.
        :param str end_date: Include actions before this date.
        :param str user_identity: Include actions performed by this user.
        :param str source_id: Include actions on this component.
        :return: HistoryEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.query_history_with_http_info(offset, count, **kwargs)  # noqa: E501
        else:
            (data) = self.query_history_with_http_info(offset, count, **kwargs)  # noqa: E501
            return data

    def query_history_with_http_info(self, offset, count, **kwargs):  # noqa: E501
        """Gets configuration history  # noqa: E501

        Note: This endpoint is subject to change as NiFi and it's REST API evolve.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.query_history_with_http_info(offset, count, async=True)
        >>> result = thread.get()

        :param async bool
        :param str offset: The offset into the result set. (required)
        :param str count: The number of actions to return. (required)
        :param str sort_column: The field to sort on.
        :param str sort_order: The direction to sort.
        :param str start_date: Include actions after this date.
        :param str end_date: Include actions before this date.
        :param str user_identity: Include actions performed by this user.
        :param str source_id: Include actions on this component.
        :return: HistoryEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['offset', 'count', 'sort_column', 'sort_order', 'start_date', 'end_date', 'user_identity', 'source_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method query_history" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'offset' is set
        if ('offset' not in params or
                params['offset'] is None):
            raise ValueError("Missing the required parameter `offset` when calling `query_history`")  # noqa: E501
        # verify the required parameter 'count' is set
        if ('count' not in params or
                params['count'] is None):
            raise ValueError("Missing the required parameter `count` when calling `query_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'count' in params:
            query_params.append(('count', params['count']))  # noqa: E501
        if 'sort_column' in params:
            query_params.append(('sortColumn', params['sort_column']))  # noqa: E501
        if 'sort_order' in params:
            query_params.append(('sortOrder', params['sort_order']))  # noqa: E501
        if 'start_date' in params:
            query_params.append(('startDate', params['start_date']))  # noqa: E501
        if 'end_date' in params:
            query_params.append(('endDate', params['end_date']))  # noqa: E501
        if 'user_identity' in params:
            query_params.append(('userIdentity', params['user_identity']))  # noqa: E501
        if 'source_id' in params:
            query_params.append(('sourceId', params['source_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/flow/history', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='HistoryEntity',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schedule_components(self, id, body, **kwargs):  # noqa: E501
        """Schedule or unschedule components in the specified Process Group.  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.schedule_components(id, body, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: The process group id. (required)
        :param ScheduleComponentsEntity body: The request to schedule or unschedule. If the comopnents in the request are not specified, all authorized components will be considered. (required)
        :return: ScheduleComponentsEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.schedule_components_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.schedule_components_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def schedule_components_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """Schedule or unschedule components in the specified Process Group.  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.schedule_components_with_http_info(id, body, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: The process group id. (required)
        :param ScheduleComponentsEntity body: The request to schedule or unschedule. If the comopnents in the request are not specified, all authorized components will be considered. (required)
        :return: ScheduleComponentsEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schedule_components" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `schedule_components`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `schedule_components`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/flow/process-groups/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ScheduleComponentsEntity',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_cluster(self, q, **kwargs):  # noqa: E501
        """Searches the cluster for a node with the specified address  # noqa: E501

        Note: This endpoint is subject to change as NiFi and it's REST API evolve.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_cluster(q, async=True)
        >>> result = thread.get()

        :param async bool
        :param str q: Node address to search for. (required)
        :return: ClusterSearchResultsEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_cluster_with_http_info(q, **kwargs)  # noqa: E501
        else:
            (data) = self.search_cluster_with_http_info(q, **kwargs)  # noqa: E501
            return data

    def search_cluster_with_http_info(self, q, **kwargs):  # noqa: E501
        """Searches the cluster for a node with the specified address  # noqa: E501

        Note: This endpoint is subject to change as NiFi and it's REST API evolve.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_cluster_with_http_info(q, async=True)
        >>> result = thread.get()

        :param async bool
        :param str q: Node address to search for. (required)
        :return: ClusterSearchResultsEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['q']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_cluster" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'q' is set
        if ('q' not in params or
                params['q'] is None):
            raise ValueError("Missing the required parameter `q` when calling `search_cluster`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'q' in params:
            query_params.append(('q', params['q']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/flow/cluster/search-results', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClusterSearchResultsEntity',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_flow(self, **kwargs):  # noqa: E501
        """Performs a search against this NiFi using the specified search term  # noqa: E501

        Only search results from authorized components will be returned.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_flow(async=True)
        >>> result = thread.get()

        :param async bool
        :param str q:
        :return: SearchResultsEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_flow_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_flow_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_flow_with_http_info(self, **kwargs):  # noqa: E501
        """Performs a search against this NiFi using the specified search term  # noqa: E501

        Only search results from authorized components will be returned.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_flow_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str q:
        :return: SearchResultsEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['q']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_flow" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'q' in params:
            query_params.append(('q', params['q']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/flow/search-results', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SearchResultsEntity',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
